;buildInfoPackage: chisel3, version: 3.4.2, scalaVersion: 2.12.12, sbtVersion: 1.3.10
circuit WatermanSystolic : 
  module substituteElements : 
    input clock : Clock
    input reset : Reset
    output io : {flip first : UInt<2>, flip second : UInt<2>, out : SInt<32>}
    
    io.out <= asSInt(UInt<2>("h01")) @[DNA.scala 27:10]
    node _T = eq(io.first, io.second) @[DNA.scala 28:18]
    when _T : @[DNA.scala 28:33]
      io.out <= asSInt(UInt<2>("h01")) @[DNA.scala 29:12]
      skip @[DNA.scala 28:33]
    else : @[DNA.scala 30:16]
      io.out <= asSInt(UInt<2>("h03")) @[DNA.scala 31:12]
      skip @[DNA.scala 30:16]
    
  module processingElementDecoupled : 
    input clock : Clock
    input reset : Reset
    output io : {flip fromPreviousPE : {flip ready : UInt<1>, valid : UInt<1>, bits : {upper : SInt<32>, diagonal : SInt<32>, columnElement : UInt<2>}}, flip rowElement : UInt<2>, flip reset : UInt<1>, flip number : UInt<32>, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {score : SInt<32>, x : UInt<2>, y : UInt<2>}}, toNextPE : {flip ready : UInt<1>, valid : UInt<1>, bits : {upper : SInt<32>, diagonal : SInt<32>, columnElement : UInt<2>}}}
    
    reg stateReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 112:25]
    reg toNextPeValidReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 113:33]
    reg scoreValidReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 114:30]
    reg previousScore : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 115:30]
    reg leftReg : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 116:24]
    reg diagReg : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 117:24]
    reg upperReg : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 118:25]
    reg columnElementReg : UInt<2>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 119:33]
    reg stepReg : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[WatermanSystolic.scala 120:24]
    inst substituteElements of substituteElements @[WatermanSystolic.scala 122:34]
    substituteElements.clock <= clock
    substituteElements.reset <= reset
    substituteElements.io.first <= io.rowElement @[WatermanSystolic.scala 123:31]
    substituteElements.io.second <= columnElementReg @[WatermanSystolic.scala 124:32]
    wire upper : SInt<32> @[WatermanSystolic.scala 125:31]
    wire diag : SInt<32> @[WatermanSystolic.scala 125:31]
    wire left : SInt<32> @[WatermanSystolic.scala 125:31]
    wire diagOrUpper : SInt<32> @[WatermanSystolic.scala 126:49]
    wire diagOrLeft : SInt<32> @[WatermanSystolic.scala 126:49]
    wire max : SInt<32> @[WatermanSystolic.scala 126:49]
    wire score : SInt<32> @[WatermanSystolic.scala 126:49]
    node _T = add(diagReg, substituteElements.io.out) @[WatermanSystolic.scala 127:19]
    node _T_1 = tail(_T, 1) @[WatermanSystolic.scala 127:19]
    node _T_2 = asSInt(_T_1) @[WatermanSystolic.scala 127:19]
    diag <= _T_2 @[WatermanSystolic.scala 127:8]
    node _T_3 = sub(upperReg, asSInt(UInt<3>("h02"))) @[WatermanSystolic.scala 128:21]
    node _T_4 = tail(_T_3, 1) @[WatermanSystolic.scala 128:21]
    node _T_5 = asSInt(_T_4) @[WatermanSystolic.scala 128:21]
    upper <= _T_5 @[WatermanSystolic.scala 128:9]
    node _T_6 = sub(leftReg, asSInt(UInt<3>("h02"))) @[WatermanSystolic.scala 129:19]
    node _T_7 = tail(_T_6, 1) @[WatermanSystolic.scala 129:19]
    node _T_8 = asSInt(_T_7) @[WatermanSystolic.scala 129:19]
    left <= _T_8 @[WatermanSystolic.scala 129:8]
    node _T_9 = eq(stateReg, UInt<1>("h00")) @[WatermanSystolic.scala 131:39]
    io.fromPreviousPE.ready <= _T_9 @[WatermanSystolic.scala 131:27]
    io.toNextPE.valid <= toNextPeValidReg @[WatermanSystolic.scala 132:21]
    io.out.valid <= scoreValidReg @[WatermanSystolic.scala 133:16]
    io.out.bits.score <= score @[WatermanSystolic.scala 134:21]
    io.out.bits.y <= io.number @[WatermanSystolic.scala 135:17]
    io.out.bits.x <= stepReg @[WatermanSystolic.scala 136:17]
    io.toNextPE.bits.upper <= score @[WatermanSystolic.scala 137:26]
    io.toNextPE.bits.diagonal <= previousScore @[WatermanSystolic.scala 138:29]
    io.toNextPE.bits.columnElement <= columnElementReg @[WatermanSystolic.scala 139:34]
    node _T_10 = gt(diag, upper) @[WatermanSystolic.scala 141:13]
    when _T_10 : @[WatermanSystolic.scala 141:22]
      diagOrUpper <= diag @[WatermanSystolic.scala 142:17]
      skip @[WatermanSystolic.scala 141:22]
    else : @[WatermanSystolic.scala 143:15]
      diagOrUpper <= upper @[WatermanSystolic.scala 144:17]
      skip @[WatermanSystolic.scala 143:15]
    node _T_11 = gt(diag, left) @[WatermanSystolic.scala 146:13]
    when _T_11 : @[WatermanSystolic.scala 146:21]
      diagOrLeft <= diag @[WatermanSystolic.scala 147:16]
      skip @[WatermanSystolic.scala 146:21]
    else : @[WatermanSystolic.scala 148:15]
      diagOrLeft <= left @[WatermanSystolic.scala 149:16]
      skip @[WatermanSystolic.scala 148:15]
    node _T_12 = gt(diagOrLeft, diagOrUpper) @[WatermanSystolic.scala 151:19]
    when _T_12 : @[WatermanSystolic.scala 151:34]
      max <= diagOrLeft @[WatermanSystolic.scala 152:9]
      skip @[WatermanSystolic.scala 151:34]
    else : @[WatermanSystolic.scala 153:15]
      max <= diagOrUpper @[WatermanSystolic.scala 154:9]
      skip @[WatermanSystolic.scala 153:15]
    node _T_13 = gt(max, asSInt(UInt<1>("h00"))) @[WatermanSystolic.scala 158:14]
    when _T_13 : @[WatermanSystolic.scala 158:35]
      score <= max @[WatermanSystolic.scala 159:13]
      skip @[WatermanSystolic.scala 158:35]
    else : @[WatermanSystolic.scala 160:17]
      score <= asSInt(UInt<1>("h00")) @[WatermanSystolic.scala 161:13]
      skip @[WatermanSystolic.scala 160:17]
    when io.reset : @[WatermanSystolic.scala 167:18]
      previousScore <= asSInt(UInt<1>("h00")) @[WatermanSystolic.scala 168:19]
      leftReg <= asSInt(UInt<1>("h00")) @[WatermanSystolic.scala 169:13]
      stepReg <= UInt<1>("h00") @[WatermanSystolic.scala 170:13]
      stateReg <= UInt<1>("h00") @[WatermanSystolic.scala 171:14]
      skip @[WatermanSystolic.scala 167:18]
    else : @[WatermanSystolic.scala 172:15]
      node _T_14 = eq(UInt<1>("h00"), stateReg) @[Conditional.scala 37:30]
      when _T_14 : @[Conditional.scala 40:58]
        when io.fromPreviousPE.valid : @[WatermanSystolic.scala 175:39]
          upperReg <= io.fromPreviousPE.bits.upper @[WatermanSystolic.scala 176:20]
          diagReg <= io.fromPreviousPE.bits.diagonal @[WatermanSystolic.scala 177:19]
          columnElementReg <= io.fromPreviousPE.bits.columnElement @[WatermanSystolic.scala 178:28]
          scoreValidReg <= UInt<1>("h01") @[WatermanSystolic.scala 180:25]
          toNextPeValidReg <= UInt<1>("h01") @[WatermanSystolic.scala 181:28]
          stateReg <= UInt<1>("h01") @[WatermanSystolic.scala 182:20]
          skip @[WatermanSystolic.scala 175:39]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_15 = eq(UInt<1>("h01"), stateReg) @[Conditional.scala 37:30]
        when _T_15 : @[Conditional.scala 39:67]
          when io.out.ready : @[WatermanSystolic.scala 186:28]
            scoreValidReg <= UInt<1>("h00") @[WatermanSystolic.scala 187:25]
            skip @[WatermanSystolic.scala 186:28]
          when io.toNextPE.ready : @[WatermanSystolic.scala 189:33]
            toNextPeValidReg <= UInt<1>("h00") @[WatermanSystolic.scala 190:28]
            skip @[WatermanSystolic.scala 189:33]
          node _T_16 = or(scoreValidReg, toNextPeValidReg) @[WatermanSystolic.scala 192:30]
          node _T_17 = eq(_T_16, UInt<1>("h00")) @[WatermanSystolic.scala 192:14]
          when _T_17 : @[WatermanSystolic.scala 192:52]
            previousScore <= score @[WatermanSystolic.scala 193:25]
            stateReg <= UInt<1>("h00") @[WatermanSystolic.scala 194:20]
            node _T_18 = add(stepReg, UInt<1>("h01")) @[WatermanSystolic.scala 195:30]
            node _T_19 = tail(_T_18, 1) @[WatermanSystolic.scala 195:30]
            stepReg <= _T_19 @[WatermanSystolic.scala 195:19]
            leftReg <= score @[WatermanSystolic.scala 196:19]
            skip @[WatermanSystolic.scala 192:52]
          skip @[Conditional.scala 39:67]
      skip @[WatermanSystolic.scala 172:15]
    
  module substituteElements_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip first : UInt<2>, flip second : UInt<2>, out : SInt<32>}
    
    io.out <= asSInt(UInt<2>("h01")) @[DNA.scala 27:10]
    node _T = eq(io.first, io.second) @[DNA.scala 28:18]
    when _T : @[DNA.scala 28:33]
      io.out <= asSInt(UInt<2>("h01")) @[DNA.scala 29:12]
      skip @[DNA.scala 28:33]
    else : @[DNA.scala 30:16]
      io.out <= asSInt(UInt<2>("h03")) @[DNA.scala 31:12]
      skip @[DNA.scala 30:16]
    
  module processingElementDecoupled_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip fromPreviousPE : {flip ready : UInt<1>, valid : UInt<1>, bits : {upper : SInt<32>, diagonal : SInt<32>, columnElement : UInt<2>}}, flip rowElement : UInt<2>, flip reset : UInt<1>, flip number : UInt<32>, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {score : SInt<32>, x : UInt<2>, y : UInt<2>}}, toNextPE : {flip ready : UInt<1>, valid : UInt<1>, bits : {upper : SInt<32>, diagonal : SInt<32>, columnElement : UInt<2>}}}
    
    reg stateReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 112:25]
    reg toNextPeValidReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 113:33]
    reg scoreValidReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 114:30]
    reg previousScore : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 115:30]
    reg leftReg : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 116:24]
    reg diagReg : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 117:24]
    reg upperReg : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 118:25]
    reg columnElementReg : UInt<2>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 119:33]
    reg stepReg : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[WatermanSystolic.scala 120:24]
    inst substituteElements of substituteElements_1 @[WatermanSystolic.scala 122:34]
    substituteElements.clock <= clock
    substituteElements.reset <= reset
    substituteElements.io.first <= io.rowElement @[WatermanSystolic.scala 123:31]
    substituteElements.io.second <= columnElementReg @[WatermanSystolic.scala 124:32]
    wire upper : SInt<32> @[WatermanSystolic.scala 125:31]
    wire diag : SInt<32> @[WatermanSystolic.scala 125:31]
    wire left : SInt<32> @[WatermanSystolic.scala 125:31]
    wire diagOrUpper : SInt<32> @[WatermanSystolic.scala 126:49]
    wire diagOrLeft : SInt<32> @[WatermanSystolic.scala 126:49]
    wire max : SInt<32> @[WatermanSystolic.scala 126:49]
    wire score : SInt<32> @[WatermanSystolic.scala 126:49]
    node _T = add(diagReg, substituteElements.io.out) @[WatermanSystolic.scala 127:19]
    node _T_1 = tail(_T, 1) @[WatermanSystolic.scala 127:19]
    node _T_2 = asSInt(_T_1) @[WatermanSystolic.scala 127:19]
    diag <= _T_2 @[WatermanSystolic.scala 127:8]
    node _T_3 = sub(upperReg, asSInt(UInt<3>("h02"))) @[WatermanSystolic.scala 128:21]
    node _T_4 = tail(_T_3, 1) @[WatermanSystolic.scala 128:21]
    node _T_5 = asSInt(_T_4) @[WatermanSystolic.scala 128:21]
    upper <= _T_5 @[WatermanSystolic.scala 128:9]
    node _T_6 = sub(leftReg, asSInt(UInt<3>("h02"))) @[WatermanSystolic.scala 129:19]
    node _T_7 = tail(_T_6, 1) @[WatermanSystolic.scala 129:19]
    node _T_8 = asSInt(_T_7) @[WatermanSystolic.scala 129:19]
    left <= _T_8 @[WatermanSystolic.scala 129:8]
    node _T_9 = eq(stateReg, UInt<1>("h00")) @[WatermanSystolic.scala 131:39]
    io.fromPreviousPE.ready <= _T_9 @[WatermanSystolic.scala 131:27]
    io.toNextPE.valid <= toNextPeValidReg @[WatermanSystolic.scala 132:21]
    io.out.valid <= scoreValidReg @[WatermanSystolic.scala 133:16]
    io.out.bits.score <= score @[WatermanSystolic.scala 134:21]
    io.out.bits.y <= io.number @[WatermanSystolic.scala 135:17]
    io.out.bits.x <= stepReg @[WatermanSystolic.scala 136:17]
    io.toNextPE.bits.upper <= score @[WatermanSystolic.scala 137:26]
    io.toNextPE.bits.diagonal <= previousScore @[WatermanSystolic.scala 138:29]
    io.toNextPE.bits.columnElement <= columnElementReg @[WatermanSystolic.scala 139:34]
    node _T_10 = gt(diag, upper) @[WatermanSystolic.scala 141:13]
    when _T_10 : @[WatermanSystolic.scala 141:22]
      diagOrUpper <= diag @[WatermanSystolic.scala 142:17]
      skip @[WatermanSystolic.scala 141:22]
    else : @[WatermanSystolic.scala 143:15]
      diagOrUpper <= upper @[WatermanSystolic.scala 144:17]
      skip @[WatermanSystolic.scala 143:15]
    node _T_11 = gt(diag, left) @[WatermanSystolic.scala 146:13]
    when _T_11 : @[WatermanSystolic.scala 146:21]
      diagOrLeft <= diag @[WatermanSystolic.scala 147:16]
      skip @[WatermanSystolic.scala 146:21]
    else : @[WatermanSystolic.scala 148:15]
      diagOrLeft <= left @[WatermanSystolic.scala 149:16]
      skip @[WatermanSystolic.scala 148:15]
    node _T_12 = gt(diagOrLeft, diagOrUpper) @[WatermanSystolic.scala 151:19]
    when _T_12 : @[WatermanSystolic.scala 151:34]
      max <= diagOrLeft @[WatermanSystolic.scala 152:9]
      skip @[WatermanSystolic.scala 151:34]
    else : @[WatermanSystolic.scala 153:15]
      max <= diagOrUpper @[WatermanSystolic.scala 154:9]
      skip @[WatermanSystolic.scala 153:15]
    node _T_13 = gt(max, asSInt(UInt<1>("h00"))) @[WatermanSystolic.scala 158:14]
    when _T_13 : @[WatermanSystolic.scala 158:35]
      score <= max @[WatermanSystolic.scala 159:13]
      skip @[WatermanSystolic.scala 158:35]
    else : @[WatermanSystolic.scala 160:17]
      score <= asSInt(UInt<1>("h00")) @[WatermanSystolic.scala 161:13]
      skip @[WatermanSystolic.scala 160:17]
    when io.reset : @[WatermanSystolic.scala 167:18]
      previousScore <= asSInt(UInt<1>("h00")) @[WatermanSystolic.scala 168:19]
      leftReg <= asSInt(UInt<1>("h00")) @[WatermanSystolic.scala 169:13]
      stepReg <= UInt<1>("h00") @[WatermanSystolic.scala 170:13]
      stateReg <= UInt<1>("h00") @[WatermanSystolic.scala 171:14]
      skip @[WatermanSystolic.scala 167:18]
    else : @[WatermanSystolic.scala 172:15]
      node _T_14 = eq(UInt<1>("h00"), stateReg) @[Conditional.scala 37:30]
      when _T_14 : @[Conditional.scala 40:58]
        when io.fromPreviousPE.valid : @[WatermanSystolic.scala 175:39]
          upperReg <= io.fromPreviousPE.bits.upper @[WatermanSystolic.scala 176:20]
          diagReg <= io.fromPreviousPE.bits.diagonal @[WatermanSystolic.scala 177:19]
          columnElementReg <= io.fromPreviousPE.bits.columnElement @[WatermanSystolic.scala 178:28]
          scoreValidReg <= UInt<1>("h01") @[WatermanSystolic.scala 180:25]
          toNextPeValidReg <= UInt<1>("h01") @[WatermanSystolic.scala 181:28]
          stateReg <= UInt<1>("h01") @[WatermanSystolic.scala 182:20]
          skip @[WatermanSystolic.scala 175:39]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_15 = eq(UInt<1>("h01"), stateReg) @[Conditional.scala 37:30]
        when _T_15 : @[Conditional.scala 39:67]
          when io.out.ready : @[WatermanSystolic.scala 186:28]
            scoreValidReg <= UInt<1>("h00") @[WatermanSystolic.scala 187:25]
            skip @[WatermanSystolic.scala 186:28]
          when io.toNextPE.ready : @[WatermanSystolic.scala 189:33]
            toNextPeValidReg <= UInt<1>("h00") @[WatermanSystolic.scala 190:28]
            skip @[WatermanSystolic.scala 189:33]
          node _T_16 = or(scoreValidReg, toNextPeValidReg) @[WatermanSystolic.scala 192:30]
          node _T_17 = eq(_T_16, UInt<1>("h00")) @[WatermanSystolic.scala 192:14]
          when _T_17 : @[WatermanSystolic.scala 192:52]
            previousScore <= score @[WatermanSystolic.scala 193:25]
            stateReg <= UInt<1>("h00") @[WatermanSystolic.scala 194:20]
            node _T_18 = add(stepReg, UInt<1>("h01")) @[WatermanSystolic.scala 195:30]
            node _T_19 = tail(_T_18, 1) @[WatermanSystolic.scala 195:30]
            stepReg <= _T_19 @[WatermanSystolic.scala 195:19]
            leftReg <= score @[WatermanSystolic.scala 196:19]
            skip @[WatermanSystolic.scala 192:52]
          skip @[Conditional.scala 39:67]
      skip @[WatermanSystolic.scala 172:15]
    
  module substituteElements_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip first : UInt<2>, flip second : UInt<2>, out : SInt<32>}
    
    io.out <= asSInt(UInt<2>("h01")) @[DNA.scala 27:10]
    node _T = eq(io.first, io.second) @[DNA.scala 28:18]
    when _T : @[DNA.scala 28:33]
      io.out <= asSInt(UInt<2>("h01")) @[DNA.scala 29:12]
      skip @[DNA.scala 28:33]
    else : @[DNA.scala 30:16]
      io.out <= asSInt(UInt<2>("h03")) @[DNA.scala 31:12]
      skip @[DNA.scala 30:16]
    
  module processingElementDecoupled_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip fromPreviousPE : {flip ready : UInt<1>, valid : UInt<1>, bits : {upper : SInt<32>, diagonal : SInt<32>, columnElement : UInt<2>}}, flip rowElement : UInt<2>, flip reset : UInt<1>, flip number : UInt<32>, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {score : SInt<32>, x : UInt<2>, y : UInt<2>}}, toNextPE : {flip ready : UInt<1>, valid : UInt<1>, bits : {upper : SInt<32>, diagonal : SInt<32>, columnElement : UInt<2>}}}
    
    reg stateReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 112:25]
    reg toNextPeValidReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 113:33]
    reg scoreValidReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 114:30]
    reg previousScore : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 115:30]
    reg leftReg : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 116:24]
    reg diagReg : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 117:24]
    reg upperReg : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 118:25]
    reg columnElementReg : UInt<2>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 119:33]
    reg stepReg : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[WatermanSystolic.scala 120:24]
    inst substituteElements of substituteElements_2 @[WatermanSystolic.scala 122:34]
    substituteElements.clock <= clock
    substituteElements.reset <= reset
    substituteElements.io.first <= io.rowElement @[WatermanSystolic.scala 123:31]
    substituteElements.io.second <= columnElementReg @[WatermanSystolic.scala 124:32]
    wire upper : SInt<32> @[WatermanSystolic.scala 125:31]
    wire diag : SInt<32> @[WatermanSystolic.scala 125:31]
    wire left : SInt<32> @[WatermanSystolic.scala 125:31]
    wire diagOrUpper : SInt<32> @[WatermanSystolic.scala 126:49]
    wire diagOrLeft : SInt<32> @[WatermanSystolic.scala 126:49]
    wire max : SInt<32> @[WatermanSystolic.scala 126:49]
    wire score : SInt<32> @[WatermanSystolic.scala 126:49]
    node _T = add(diagReg, substituteElements.io.out) @[WatermanSystolic.scala 127:19]
    node _T_1 = tail(_T, 1) @[WatermanSystolic.scala 127:19]
    node _T_2 = asSInt(_T_1) @[WatermanSystolic.scala 127:19]
    diag <= _T_2 @[WatermanSystolic.scala 127:8]
    node _T_3 = sub(upperReg, asSInt(UInt<3>("h02"))) @[WatermanSystolic.scala 128:21]
    node _T_4 = tail(_T_3, 1) @[WatermanSystolic.scala 128:21]
    node _T_5 = asSInt(_T_4) @[WatermanSystolic.scala 128:21]
    upper <= _T_5 @[WatermanSystolic.scala 128:9]
    node _T_6 = sub(leftReg, asSInt(UInt<3>("h02"))) @[WatermanSystolic.scala 129:19]
    node _T_7 = tail(_T_6, 1) @[WatermanSystolic.scala 129:19]
    node _T_8 = asSInt(_T_7) @[WatermanSystolic.scala 129:19]
    left <= _T_8 @[WatermanSystolic.scala 129:8]
    node _T_9 = eq(stateReg, UInt<1>("h00")) @[WatermanSystolic.scala 131:39]
    io.fromPreviousPE.ready <= _T_9 @[WatermanSystolic.scala 131:27]
    io.toNextPE.valid <= toNextPeValidReg @[WatermanSystolic.scala 132:21]
    io.out.valid <= scoreValidReg @[WatermanSystolic.scala 133:16]
    io.out.bits.score <= score @[WatermanSystolic.scala 134:21]
    io.out.bits.y <= io.number @[WatermanSystolic.scala 135:17]
    io.out.bits.x <= stepReg @[WatermanSystolic.scala 136:17]
    io.toNextPE.bits.upper <= score @[WatermanSystolic.scala 137:26]
    io.toNextPE.bits.diagonal <= previousScore @[WatermanSystolic.scala 138:29]
    io.toNextPE.bits.columnElement <= columnElementReg @[WatermanSystolic.scala 139:34]
    node _T_10 = gt(diag, upper) @[WatermanSystolic.scala 141:13]
    when _T_10 : @[WatermanSystolic.scala 141:22]
      diagOrUpper <= diag @[WatermanSystolic.scala 142:17]
      skip @[WatermanSystolic.scala 141:22]
    else : @[WatermanSystolic.scala 143:15]
      diagOrUpper <= upper @[WatermanSystolic.scala 144:17]
      skip @[WatermanSystolic.scala 143:15]
    node _T_11 = gt(diag, left) @[WatermanSystolic.scala 146:13]
    when _T_11 : @[WatermanSystolic.scala 146:21]
      diagOrLeft <= diag @[WatermanSystolic.scala 147:16]
      skip @[WatermanSystolic.scala 146:21]
    else : @[WatermanSystolic.scala 148:15]
      diagOrLeft <= left @[WatermanSystolic.scala 149:16]
      skip @[WatermanSystolic.scala 148:15]
    node _T_12 = gt(diagOrLeft, diagOrUpper) @[WatermanSystolic.scala 151:19]
    when _T_12 : @[WatermanSystolic.scala 151:34]
      max <= diagOrLeft @[WatermanSystolic.scala 152:9]
      skip @[WatermanSystolic.scala 151:34]
    else : @[WatermanSystolic.scala 153:15]
      max <= diagOrUpper @[WatermanSystolic.scala 154:9]
      skip @[WatermanSystolic.scala 153:15]
    node _T_13 = gt(max, asSInt(UInt<1>("h00"))) @[WatermanSystolic.scala 158:14]
    when _T_13 : @[WatermanSystolic.scala 158:35]
      score <= max @[WatermanSystolic.scala 159:13]
      skip @[WatermanSystolic.scala 158:35]
    else : @[WatermanSystolic.scala 160:17]
      score <= asSInt(UInt<1>("h00")) @[WatermanSystolic.scala 161:13]
      skip @[WatermanSystolic.scala 160:17]
    when io.reset : @[WatermanSystolic.scala 167:18]
      previousScore <= asSInt(UInt<1>("h00")) @[WatermanSystolic.scala 168:19]
      leftReg <= asSInt(UInt<1>("h00")) @[WatermanSystolic.scala 169:13]
      stepReg <= UInt<1>("h00") @[WatermanSystolic.scala 170:13]
      stateReg <= UInt<1>("h00") @[WatermanSystolic.scala 171:14]
      skip @[WatermanSystolic.scala 167:18]
    else : @[WatermanSystolic.scala 172:15]
      node _T_14 = eq(UInt<1>("h00"), stateReg) @[Conditional.scala 37:30]
      when _T_14 : @[Conditional.scala 40:58]
        when io.fromPreviousPE.valid : @[WatermanSystolic.scala 175:39]
          upperReg <= io.fromPreviousPE.bits.upper @[WatermanSystolic.scala 176:20]
          diagReg <= io.fromPreviousPE.bits.diagonal @[WatermanSystolic.scala 177:19]
          columnElementReg <= io.fromPreviousPE.bits.columnElement @[WatermanSystolic.scala 178:28]
          scoreValidReg <= UInt<1>("h01") @[WatermanSystolic.scala 180:25]
          toNextPeValidReg <= UInt<1>("h01") @[WatermanSystolic.scala 181:28]
          stateReg <= UInt<1>("h01") @[WatermanSystolic.scala 182:20]
          skip @[WatermanSystolic.scala 175:39]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_15 = eq(UInt<1>("h01"), stateReg) @[Conditional.scala 37:30]
        when _T_15 : @[Conditional.scala 39:67]
          when io.out.ready : @[WatermanSystolic.scala 186:28]
            scoreValidReg <= UInt<1>("h00") @[WatermanSystolic.scala 187:25]
            skip @[WatermanSystolic.scala 186:28]
          when io.toNextPE.ready : @[WatermanSystolic.scala 189:33]
            toNextPeValidReg <= UInt<1>("h00") @[WatermanSystolic.scala 190:28]
            skip @[WatermanSystolic.scala 189:33]
          node _T_16 = or(scoreValidReg, toNextPeValidReg) @[WatermanSystolic.scala 192:30]
          node _T_17 = eq(_T_16, UInt<1>("h00")) @[WatermanSystolic.scala 192:14]
          when _T_17 : @[WatermanSystolic.scala 192:52]
            previousScore <= score @[WatermanSystolic.scala 193:25]
            stateReg <= UInt<1>("h00") @[WatermanSystolic.scala 194:20]
            node _T_18 = add(stepReg, UInt<1>("h01")) @[WatermanSystolic.scala 195:30]
            node _T_19 = tail(_T_18, 1) @[WatermanSystolic.scala 195:30]
            stepReg <= _T_19 @[WatermanSystolic.scala 195:19]
            leftReg <= score @[WatermanSystolic.scala 196:19]
            skip @[WatermanSystolic.scala 192:52]
          skip @[Conditional.scala 39:67]
      skip @[WatermanSystolic.scala 172:15]
    
  module substituteElements_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip first : UInt<2>, flip second : UInt<2>, out : SInt<32>}
    
    io.out <= asSInt(UInt<2>("h01")) @[DNA.scala 27:10]
    node _T = eq(io.first, io.second) @[DNA.scala 28:18]
    when _T : @[DNA.scala 28:33]
      io.out <= asSInt(UInt<2>("h01")) @[DNA.scala 29:12]
      skip @[DNA.scala 28:33]
    else : @[DNA.scala 30:16]
      io.out <= asSInt(UInt<2>("h03")) @[DNA.scala 31:12]
      skip @[DNA.scala 30:16]
    
  module processingElementDecoupled_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip fromPreviousPE : {flip ready : UInt<1>, valid : UInt<1>, bits : {upper : SInt<32>, diagonal : SInt<32>, columnElement : UInt<2>}}, flip rowElement : UInt<2>, flip reset : UInt<1>, flip number : UInt<32>, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {score : SInt<32>, x : UInt<2>, y : UInt<2>}}, toNextPE : {flip ready : UInt<1>, valid : UInt<1>, bits : {upper : SInt<32>, diagonal : SInt<32>, columnElement : UInt<2>}}}
    
    reg stateReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 112:25]
    reg toNextPeValidReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 113:33]
    reg scoreValidReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 114:30]
    reg previousScore : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 115:30]
    reg leftReg : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 116:24]
    reg diagReg : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 117:24]
    reg upperReg : SInt<32>, clock with : (reset => (reset, asSInt(UInt<32>("h00")))) @[WatermanSystolic.scala 118:25]
    reg columnElementReg : UInt<2>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 119:33]
    reg stepReg : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[WatermanSystolic.scala 120:24]
    inst substituteElements of substituteElements_3 @[WatermanSystolic.scala 122:34]
    substituteElements.clock <= clock
    substituteElements.reset <= reset
    substituteElements.io.first <= io.rowElement @[WatermanSystolic.scala 123:31]
    substituteElements.io.second <= columnElementReg @[WatermanSystolic.scala 124:32]
    wire upper : SInt<32> @[WatermanSystolic.scala 125:31]
    wire diag : SInt<32> @[WatermanSystolic.scala 125:31]
    wire left : SInt<32> @[WatermanSystolic.scala 125:31]
    wire diagOrUpper : SInt<32> @[WatermanSystolic.scala 126:49]
    wire diagOrLeft : SInt<32> @[WatermanSystolic.scala 126:49]
    wire max : SInt<32> @[WatermanSystolic.scala 126:49]
    wire score : SInt<32> @[WatermanSystolic.scala 126:49]
    node _T = add(diagReg, substituteElements.io.out) @[WatermanSystolic.scala 127:19]
    node _T_1 = tail(_T, 1) @[WatermanSystolic.scala 127:19]
    node _T_2 = asSInt(_T_1) @[WatermanSystolic.scala 127:19]
    diag <= _T_2 @[WatermanSystolic.scala 127:8]
    node _T_3 = sub(upperReg, asSInt(UInt<3>("h02"))) @[WatermanSystolic.scala 128:21]
    node _T_4 = tail(_T_3, 1) @[WatermanSystolic.scala 128:21]
    node _T_5 = asSInt(_T_4) @[WatermanSystolic.scala 128:21]
    upper <= _T_5 @[WatermanSystolic.scala 128:9]
    node _T_6 = sub(leftReg, asSInt(UInt<3>("h02"))) @[WatermanSystolic.scala 129:19]
    node _T_7 = tail(_T_6, 1) @[WatermanSystolic.scala 129:19]
    node _T_8 = asSInt(_T_7) @[WatermanSystolic.scala 129:19]
    left <= _T_8 @[WatermanSystolic.scala 129:8]
    node _T_9 = eq(stateReg, UInt<1>("h00")) @[WatermanSystolic.scala 131:39]
    io.fromPreviousPE.ready <= _T_9 @[WatermanSystolic.scala 131:27]
    io.toNextPE.valid <= toNextPeValidReg @[WatermanSystolic.scala 132:21]
    io.out.valid <= scoreValidReg @[WatermanSystolic.scala 133:16]
    io.out.bits.score <= score @[WatermanSystolic.scala 134:21]
    io.out.bits.y <= io.number @[WatermanSystolic.scala 135:17]
    io.out.bits.x <= stepReg @[WatermanSystolic.scala 136:17]
    io.toNextPE.bits.upper <= score @[WatermanSystolic.scala 137:26]
    io.toNextPE.bits.diagonal <= previousScore @[WatermanSystolic.scala 138:29]
    io.toNextPE.bits.columnElement <= columnElementReg @[WatermanSystolic.scala 139:34]
    node _T_10 = gt(diag, upper) @[WatermanSystolic.scala 141:13]
    when _T_10 : @[WatermanSystolic.scala 141:22]
      diagOrUpper <= diag @[WatermanSystolic.scala 142:17]
      skip @[WatermanSystolic.scala 141:22]
    else : @[WatermanSystolic.scala 143:15]
      diagOrUpper <= upper @[WatermanSystolic.scala 144:17]
      skip @[WatermanSystolic.scala 143:15]
    node _T_11 = gt(diag, left) @[WatermanSystolic.scala 146:13]
    when _T_11 : @[WatermanSystolic.scala 146:21]
      diagOrLeft <= diag @[WatermanSystolic.scala 147:16]
      skip @[WatermanSystolic.scala 146:21]
    else : @[WatermanSystolic.scala 148:15]
      diagOrLeft <= left @[WatermanSystolic.scala 149:16]
      skip @[WatermanSystolic.scala 148:15]
    node _T_12 = gt(diagOrLeft, diagOrUpper) @[WatermanSystolic.scala 151:19]
    when _T_12 : @[WatermanSystolic.scala 151:34]
      max <= diagOrLeft @[WatermanSystolic.scala 152:9]
      skip @[WatermanSystolic.scala 151:34]
    else : @[WatermanSystolic.scala 153:15]
      max <= diagOrUpper @[WatermanSystolic.scala 154:9]
      skip @[WatermanSystolic.scala 153:15]
    node _T_13 = gt(max, asSInt(UInt<1>("h00"))) @[WatermanSystolic.scala 158:14]
    when _T_13 : @[WatermanSystolic.scala 158:35]
      score <= max @[WatermanSystolic.scala 159:13]
      skip @[WatermanSystolic.scala 158:35]
    else : @[WatermanSystolic.scala 160:17]
      score <= asSInt(UInt<1>("h00")) @[WatermanSystolic.scala 161:13]
      skip @[WatermanSystolic.scala 160:17]
    when io.reset : @[WatermanSystolic.scala 167:18]
      previousScore <= asSInt(UInt<1>("h00")) @[WatermanSystolic.scala 168:19]
      leftReg <= asSInt(UInt<1>("h00")) @[WatermanSystolic.scala 169:13]
      stepReg <= UInt<1>("h00") @[WatermanSystolic.scala 170:13]
      stateReg <= UInt<1>("h00") @[WatermanSystolic.scala 171:14]
      skip @[WatermanSystolic.scala 167:18]
    else : @[WatermanSystolic.scala 172:15]
      node _T_14 = eq(UInt<1>("h00"), stateReg) @[Conditional.scala 37:30]
      when _T_14 : @[Conditional.scala 40:58]
        when io.fromPreviousPE.valid : @[WatermanSystolic.scala 175:39]
          upperReg <= io.fromPreviousPE.bits.upper @[WatermanSystolic.scala 176:20]
          diagReg <= io.fromPreviousPE.bits.diagonal @[WatermanSystolic.scala 177:19]
          columnElementReg <= io.fromPreviousPE.bits.columnElement @[WatermanSystolic.scala 178:28]
          scoreValidReg <= UInt<1>("h01") @[WatermanSystolic.scala 180:25]
          toNextPeValidReg <= UInt<1>("h01") @[WatermanSystolic.scala 181:28]
          stateReg <= UInt<1>("h01") @[WatermanSystolic.scala 182:20]
          skip @[WatermanSystolic.scala 175:39]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_15 = eq(UInt<1>("h01"), stateReg) @[Conditional.scala 37:30]
        when _T_15 : @[Conditional.scala 39:67]
          when io.out.ready : @[WatermanSystolic.scala 186:28]
            scoreValidReg <= UInt<1>("h00") @[WatermanSystolic.scala 187:25]
            skip @[WatermanSystolic.scala 186:28]
          when io.toNextPE.ready : @[WatermanSystolic.scala 189:33]
            toNextPeValidReg <= UInt<1>("h00") @[WatermanSystolic.scala 190:28]
            skip @[WatermanSystolic.scala 189:33]
          node _T_16 = or(scoreValidReg, toNextPeValidReg) @[WatermanSystolic.scala 192:30]
          node _T_17 = eq(_T_16, UInt<1>("h00")) @[WatermanSystolic.scala 192:14]
          when _T_17 : @[WatermanSystolic.scala 192:52]
            previousScore <= score @[WatermanSystolic.scala 193:25]
            stateReg <= UInt<1>("h00") @[WatermanSystolic.scala 194:20]
            node _T_18 = add(stepReg, UInt<1>("h01")) @[WatermanSystolic.scala 195:30]
            node _T_19 = tail(_T_18, 1) @[WatermanSystolic.scala 195:30]
            stepReg <= _T_19 @[WatermanSystolic.scala 195:19]
            leftReg <= score @[WatermanSystolic.scala 196:19]
            skip @[WatermanSystolic.scala 192:52]
          skip @[Conditional.scala 39:67]
      skip @[WatermanSystolic.scala 172:15]
    
  module WatermanSystolic : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {S : UInt<2>[4], T : UInt<2>[4]}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {score : SInt<32>, x : UInt<2>, y : UInt<2>}}[4]}
    
    reg stateReg : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[WatermanSystolic.scala 18:25]
    reg stepReg : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[WatermanSystolic.scala 19:24]
    wire _WIRE : UInt<2>[4] @[WatermanSystolic.scala 20:29]
    _WIRE[0] <= UInt<1>("h00") @[WatermanSystolic.scala 20:29]
    _WIRE[1] <= UInt<1>("h00") @[WatermanSystolic.scala 20:29]
    _WIRE[2] <= UInt<1>("h00") @[WatermanSystolic.scala 20:29]
    _WIRE[3] <= UInt<1>("h00") @[WatermanSystolic.scala 20:29]
    reg TReg : UInt<2>[4], clock with : (reset => (reset, _WIRE)) @[WatermanSystolic.scala 20:21]
    wire _WIRE_1 : UInt<2>[4] @[WatermanSystolic.scala 21:29]
    _WIRE_1[0] <= UInt<1>("h00") @[WatermanSystolic.scala 21:29]
    _WIRE_1[1] <= UInt<1>("h00") @[WatermanSystolic.scala 21:29]
    _WIRE_1[2] <= UInt<1>("h00") @[WatermanSystolic.scala 21:29]
    _WIRE_1[3] <= UInt<1>("h00") @[WatermanSystolic.scala 21:29]
    reg SReg : UInt<2>[4], clock with : (reset => (reset, _WIRE_1)) @[WatermanSystolic.scala 21:21]
    reg resetReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[WatermanSystolic.scala 22:25]
    inst processingElementDecoupled of processingElementDecoupled @[WatermanSystolic.scala 25:11]
    processingElementDecoupled.clock <= clock
    processingElementDecoupled.reset <= reset
    inst processingElementDecoupled_1 of processingElementDecoupled_1 @[WatermanSystolic.scala 25:11]
    processingElementDecoupled_1.clock <= clock
    processingElementDecoupled_1.reset <= reset
    inst processingElementDecoupled_2 of processingElementDecoupled_2 @[WatermanSystolic.scala 25:11]
    processingElementDecoupled_2.clock <= clock
    processingElementDecoupled_2.reset <= reset
    inst processingElementDecoupled_3 of processingElementDecoupled_3 @[WatermanSystolic.scala 25:11]
    processingElementDecoupled_3.clock <= clock
    processingElementDecoupled_3.reset <= reset
    wire PEs : {flip fromPreviousPE : {flip ready : UInt<1>, valid : UInt<1>, bits : {upper : SInt<32>, diagonal : SInt<32>, columnElement : UInt<2>}}, flip rowElement : UInt<2>, flip reset : UInt<1>, flip number : UInt<32>, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {score : SInt<32>, x : UInt<2>, y : UInt<2>}}, toNextPE : {flip ready : UInt<1>, valid : UInt<1>, bits : {upper : SInt<32>, diagonal : SInt<32>, columnElement : UInt<2>}}}[4] @[WatermanSystolic.scala 24:20]
    PEs[0].toNextPE.bits.columnElement <= processingElementDecoupled.io.toNextPE.bits.columnElement @[WatermanSystolic.scala 24:20]
    PEs[0].toNextPE.bits.diagonal <= processingElementDecoupled.io.toNextPE.bits.diagonal @[WatermanSystolic.scala 24:20]
    PEs[0].toNextPE.bits.upper <= processingElementDecoupled.io.toNextPE.bits.upper @[WatermanSystolic.scala 24:20]
    PEs[0].toNextPE.valid <= processingElementDecoupled.io.toNextPE.valid @[WatermanSystolic.scala 24:20]
    processingElementDecoupled.io.toNextPE.ready <= PEs[0].toNextPE.ready @[WatermanSystolic.scala 24:20]
    PEs[0].out.bits.y <= processingElementDecoupled.io.out.bits.y @[WatermanSystolic.scala 24:20]
    PEs[0].out.bits.x <= processingElementDecoupled.io.out.bits.x @[WatermanSystolic.scala 24:20]
    PEs[0].out.bits.score <= processingElementDecoupled.io.out.bits.score @[WatermanSystolic.scala 24:20]
    PEs[0].out.valid <= processingElementDecoupled.io.out.valid @[WatermanSystolic.scala 24:20]
    processingElementDecoupled.io.out.ready <= PEs[0].out.ready @[WatermanSystolic.scala 24:20]
    processingElementDecoupled.io.number <= PEs[0].number @[WatermanSystolic.scala 24:20]
    processingElementDecoupled.io.reset <= PEs[0].reset @[WatermanSystolic.scala 24:20]
    processingElementDecoupled.io.rowElement <= PEs[0].rowElement @[WatermanSystolic.scala 24:20]
    processingElementDecoupled.io.fromPreviousPE.bits.columnElement <= PEs[0].fromPreviousPE.bits.columnElement @[WatermanSystolic.scala 24:20]
    processingElementDecoupled.io.fromPreviousPE.bits.diagonal <= PEs[0].fromPreviousPE.bits.diagonal @[WatermanSystolic.scala 24:20]
    processingElementDecoupled.io.fromPreviousPE.bits.upper <= PEs[0].fromPreviousPE.bits.upper @[WatermanSystolic.scala 24:20]
    processingElementDecoupled.io.fromPreviousPE.valid <= PEs[0].fromPreviousPE.valid @[WatermanSystolic.scala 24:20]
    PEs[0].fromPreviousPE.ready <= processingElementDecoupled.io.fromPreviousPE.ready @[WatermanSystolic.scala 24:20]
    PEs[1].toNextPE.bits.columnElement <= processingElementDecoupled_1.io.toNextPE.bits.columnElement @[WatermanSystolic.scala 24:20]
    PEs[1].toNextPE.bits.diagonal <= processingElementDecoupled_1.io.toNextPE.bits.diagonal @[WatermanSystolic.scala 24:20]
    PEs[1].toNextPE.bits.upper <= processingElementDecoupled_1.io.toNextPE.bits.upper @[WatermanSystolic.scala 24:20]
    PEs[1].toNextPE.valid <= processingElementDecoupled_1.io.toNextPE.valid @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_1.io.toNextPE.ready <= PEs[1].toNextPE.ready @[WatermanSystolic.scala 24:20]
    PEs[1].out.bits.y <= processingElementDecoupled_1.io.out.bits.y @[WatermanSystolic.scala 24:20]
    PEs[1].out.bits.x <= processingElementDecoupled_1.io.out.bits.x @[WatermanSystolic.scala 24:20]
    PEs[1].out.bits.score <= processingElementDecoupled_1.io.out.bits.score @[WatermanSystolic.scala 24:20]
    PEs[1].out.valid <= processingElementDecoupled_1.io.out.valid @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_1.io.out.ready <= PEs[1].out.ready @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_1.io.number <= PEs[1].number @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_1.io.reset <= PEs[1].reset @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_1.io.rowElement <= PEs[1].rowElement @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_1.io.fromPreviousPE.bits.columnElement <= PEs[1].fromPreviousPE.bits.columnElement @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_1.io.fromPreviousPE.bits.diagonal <= PEs[1].fromPreviousPE.bits.diagonal @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_1.io.fromPreviousPE.bits.upper <= PEs[1].fromPreviousPE.bits.upper @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_1.io.fromPreviousPE.valid <= PEs[1].fromPreviousPE.valid @[WatermanSystolic.scala 24:20]
    PEs[1].fromPreviousPE.ready <= processingElementDecoupled_1.io.fromPreviousPE.ready @[WatermanSystolic.scala 24:20]
    PEs[2].toNextPE.bits.columnElement <= processingElementDecoupled_2.io.toNextPE.bits.columnElement @[WatermanSystolic.scala 24:20]
    PEs[2].toNextPE.bits.diagonal <= processingElementDecoupled_2.io.toNextPE.bits.diagonal @[WatermanSystolic.scala 24:20]
    PEs[2].toNextPE.bits.upper <= processingElementDecoupled_2.io.toNextPE.bits.upper @[WatermanSystolic.scala 24:20]
    PEs[2].toNextPE.valid <= processingElementDecoupled_2.io.toNextPE.valid @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_2.io.toNextPE.ready <= PEs[2].toNextPE.ready @[WatermanSystolic.scala 24:20]
    PEs[2].out.bits.y <= processingElementDecoupled_2.io.out.bits.y @[WatermanSystolic.scala 24:20]
    PEs[2].out.bits.x <= processingElementDecoupled_2.io.out.bits.x @[WatermanSystolic.scala 24:20]
    PEs[2].out.bits.score <= processingElementDecoupled_2.io.out.bits.score @[WatermanSystolic.scala 24:20]
    PEs[2].out.valid <= processingElementDecoupled_2.io.out.valid @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_2.io.out.ready <= PEs[2].out.ready @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_2.io.number <= PEs[2].number @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_2.io.reset <= PEs[2].reset @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_2.io.rowElement <= PEs[2].rowElement @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_2.io.fromPreviousPE.bits.columnElement <= PEs[2].fromPreviousPE.bits.columnElement @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_2.io.fromPreviousPE.bits.diagonal <= PEs[2].fromPreviousPE.bits.diagonal @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_2.io.fromPreviousPE.bits.upper <= PEs[2].fromPreviousPE.bits.upper @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_2.io.fromPreviousPE.valid <= PEs[2].fromPreviousPE.valid @[WatermanSystolic.scala 24:20]
    PEs[2].fromPreviousPE.ready <= processingElementDecoupled_2.io.fromPreviousPE.ready @[WatermanSystolic.scala 24:20]
    PEs[3].toNextPE.bits.columnElement <= processingElementDecoupled_3.io.toNextPE.bits.columnElement @[WatermanSystolic.scala 24:20]
    PEs[3].toNextPE.bits.diagonal <= processingElementDecoupled_3.io.toNextPE.bits.diagonal @[WatermanSystolic.scala 24:20]
    PEs[3].toNextPE.bits.upper <= processingElementDecoupled_3.io.toNextPE.bits.upper @[WatermanSystolic.scala 24:20]
    PEs[3].toNextPE.valid <= processingElementDecoupled_3.io.toNextPE.valid @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_3.io.toNextPE.ready <= PEs[3].toNextPE.ready @[WatermanSystolic.scala 24:20]
    PEs[3].out.bits.y <= processingElementDecoupled_3.io.out.bits.y @[WatermanSystolic.scala 24:20]
    PEs[3].out.bits.x <= processingElementDecoupled_3.io.out.bits.x @[WatermanSystolic.scala 24:20]
    PEs[3].out.bits.score <= processingElementDecoupled_3.io.out.bits.score @[WatermanSystolic.scala 24:20]
    PEs[3].out.valid <= processingElementDecoupled_3.io.out.valid @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_3.io.out.ready <= PEs[3].out.ready @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_3.io.number <= PEs[3].number @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_3.io.reset <= PEs[3].reset @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_3.io.rowElement <= PEs[3].rowElement @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_3.io.fromPreviousPE.bits.columnElement <= PEs[3].fromPreviousPE.bits.columnElement @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_3.io.fromPreviousPE.bits.diagonal <= PEs[3].fromPreviousPE.bits.diagonal @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_3.io.fromPreviousPE.bits.upper <= PEs[3].fromPreviousPE.bits.upper @[WatermanSystolic.scala 24:20]
    processingElementDecoupled_3.io.fromPreviousPE.valid <= PEs[3].fromPreviousPE.valid @[WatermanSystolic.scala 24:20]
    PEs[3].fromPreviousPE.ready <= processingElementDecoupled_3.io.fromPreviousPE.ready @[WatermanSystolic.scala 24:20]
    PEs[3].toNextPE.ready <= UInt<1>("h01") @[WatermanSystolic.scala 28:38]
    node _T = eq(stateReg, UInt<2>("h01")) @[WatermanSystolic.scala 31:47]
    PEs[0].fromPreviousPE.valid <= _T @[WatermanSystolic.scala 31:35]
    PEs[0].fromPreviousPE.bits.columnElement <= SReg[0] @[WatermanSystolic.scala 32:48]
    PEs[0].fromPreviousPE.bits.upper <= asSInt(UInt<1>("h00")) @[WatermanSystolic.scala 33:40]
    PEs[0].fromPreviousPE.bits.diagonal <= asSInt(UInt<1>("h00")) @[WatermanSystolic.scala 34:43]
    PEs[0].number <= UInt<1>("h00") @[WatermanSystolic.scala 43:19]
    PEs[0].rowElement <= TReg[0] @[WatermanSystolic.scala 44:23]
    PEs[0].reset <= resetReg @[WatermanSystolic.scala 45:18]
    io.out[0].bits.x <= PEs[0].out.bits.x @[WatermanSystolic.scala 47:22]
    io.out[0].bits.y <= PEs[0].out.bits.y @[WatermanSystolic.scala 48:22]
    io.out[0].bits.score <= PEs[0].out.bits.score @[WatermanSystolic.scala 49:26]
    io.out[0].valid <= PEs[0].out.valid @[WatermanSystolic.scala 50:21]
    PEs[0].out.ready <= io.out[0].ready @[WatermanSystolic.scala 51:22]
    PEs[0].toNextPE.ready <= PEs[1].fromPreviousPE.ready @[WatermanSystolic.scala 36:33]
    PEs[1].fromPreviousPE.valid <= PEs[0].toNextPE.valid @[WatermanSystolic.scala 37:35]
    PEs[1].fromPreviousPE.bits.upper <= PEs[0].toNextPE.bits.upper @[WatermanSystolic.scala 38:40]
    PEs[1].fromPreviousPE.bits.diagonal <= PEs[0].toNextPE.bits.diagonal @[WatermanSystolic.scala 39:43]
    PEs[1].fromPreviousPE.bits.columnElement <= PEs[0].toNextPE.bits.columnElement @[WatermanSystolic.scala 40:48]
    PEs[1].number <= UInt<1>("h01") @[WatermanSystolic.scala 43:19]
    PEs[1].rowElement <= TReg[1] @[WatermanSystolic.scala 44:23]
    PEs[1].reset <= resetReg @[WatermanSystolic.scala 45:18]
    io.out[1].bits.x <= PEs[1].out.bits.x @[WatermanSystolic.scala 47:22]
    io.out[1].bits.y <= PEs[1].out.bits.y @[WatermanSystolic.scala 48:22]
    io.out[1].bits.score <= PEs[1].out.bits.score @[WatermanSystolic.scala 49:26]
    io.out[1].valid <= PEs[1].out.valid @[WatermanSystolic.scala 50:21]
    PEs[1].out.ready <= io.out[1].ready @[WatermanSystolic.scala 51:22]
    PEs[1].toNextPE.ready <= PEs[2].fromPreviousPE.ready @[WatermanSystolic.scala 36:33]
    PEs[2].fromPreviousPE.valid <= PEs[1].toNextPE.valid @[WatermanSystolic.scala 37:35]
    PEs[2].fromPreviousPE.bits.upper <= PEs[1].toNextPE.bits.upper @[WatermanSystolic.scala 38:40]
    PEs[2].fromPreviousPE.bits.diagonal <= PEs[1].toNextPE.bits.diagonal @[WatermanSystolic.scala 39:43]
    PEs[2].fromPreviousPE.bits.columnElement <= PEs[1].toNextPE.bits.columnElement @[WatermanSystolic.scala 40:48]
    PEs[2].number <= UInt<2>("h02") @[WatermanSystolic.scala 43:19]
    PEs[2].rowElement <= TReg[2] @[WatermanSystolic.scala 44:23]
    PEs[2].reset <= resetReg @[WatermanSystolic.scala 45:18]
    io.out[2].bits.x <= PEs[2].out.bits.x @[WatermanSystolic.scala 47:22]
    io.out[2].bits.y <= PEs[2].out.bits.y @[WatermanSystolic.scala 48:22]
    io.out[2].bits.score <= PEs[2].out.bits.score @[WatermanSystolic.scala 49:26]
    io.out[2].valid <= PEs[2].out.valid @[WatermanSystolic.scala 50:21]
    PEs[2].out.ready <= io.out[2].ready @[WatermanSystolic.scala 51:22]
    PEs[2].toNextPE.ready <= PEs[3].fromPreviousPE.ready @[WatermanSystolic.scala 36:33]
    PEs[3].fromPreviousPE.valid <= PEs[2].toNextPE.valid @[WatermanSystolic.scala 37:35]
    PEs[3].fromPreviousPE.bits.upper <= PEs[2].toNextPE.bits.upper @[WatermanSystolic.scala 38:40]
    PEs[3].fromPreviousPE.bits.diagonal <= PEs[2].toNextPE.bits.diagonal @[WatermanSystolic.scala 39:43]
    PEs[3].fromPreviousPE.bits.columnElement <= PEs[2].toNextPE.bits.columnElement @[WatermanSystolic.scala 40:48]
    PEs[3].number <= UInt<2>("h03") @[WatermanSystolic.scala 43:19]
    PEs[3].rowElement <= TReg[3] @[WatermanSystolic.scala 44:23]
    PEs[3].reset <= resetReg @[WatermanSystolic.scala 45:18]
    io.out[3].bits.x <= PEs[3].out.bits.x @[WatermanSystolic.scala 47:22]
    io.out[3].bits.y <= PEs[3].out.bits.y @[WatermanSystolic.scala 48:22]
    io.out[3].bits.score <= PEs[3].out.bits.score @[WatermanSystolic.scala 49:26]
    io.out[3].valid <= PEs[3].out.valid @[WatermanSystolic.scala 50:21]
    PEs[3].out.ready <= io.out[3].ready @[WatermanSystolic.scala 51:22]
    node _T_1 = eq(stateReg, UInt<2>("h00")) @[WatermanSystolic.scala 54:27]
    io.in.ready <= _T_1 @[WatermanSystolic.scala 54:15]
    node _T_2 = eq(UInt<2>("h00"), stateReg) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      when io.in.valid : @[WatermanSystolic.scala 58:25]
        SReg[0] <= io.in.bits.S[0] @[WatermanSystolic.scala 60:19]
        SReg[1] <= io.in.bits.S[1] @[WatermanSystolic.scala 60:19]
        SReg[2] <= io.in.bits.S[2] @[WatermanSystolic.scala 60:19]
        SReg[3] <= io.in.bits.S[3] @[WatermanSystolic.scala 60:19]
        TReg[0] <= io.in.bits.T[0] @[WatermanSystolic.scala 63:19]
        TReg[1] <= io.in.bits.T[1] @[WatermanSystolic.scala 63:19]
        TReg[2] <= io.in.bits.T[2] @[WatermanSystolic.scala 63:19]
        TReg[3] <= io.in.bits.T[3] @[WatermanSystolic.scala 63:19]
        resetReg <= UInt<1>("h00") @[WatermanSystolic.scala 65:18]
        stepReg <= UInt<1>("h00") @[WatermanSystolic.scala 66:17]
        stateReg <= UInt<2>("h01") @[WatermanSystolic.scala 67:18]
        skip @[WatermanSystolic.scala 58:25]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<2>("h01"), stateReg) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        when PEs[0].fromPreviousPE.ready : @[WatermanSystolic.scala 71:41]
          SReg[0] <= SReg[1] @[WatermanSystolic.scala 73:19]
          SReg[1] <= SReg[2] @[WatermanSystolic.scala 73:19]
          SReg[2] <= SReg[3] @[WatermanSystolic.scala 73:19]
          node _T_4 = add(stepReg, UInt<1>("h01")) @[WatermanSystolic.scala 75:28]
          node _T_5 = tail(_T_4, 1) @[WatermanSystolic.scala 75:28]
          stepReg <= _T_5 @[WatermanSystolic.scala 75:17]
          node _T_6 = eq(stepReg, UInt<2>("h03")) @[WatermanSystolic.scala 76:22]
          when _T_6 : @[WatermanSystolic.scala 76:49]
            stateReg <= UInt<2>("h02") @[WatermanSystolic.scala 77:20]
            skip @[WatermanSystolic.scala 76:49]
          skip @[WatermanSystolic.scala 71:41]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_7 = eq(UInt<2>("h02"), stateReg) @[Conditional.scala 37:30]
        when _T_7 : @[Conditional.scala 39:67]
          node _T_8 = eq(PEs[3].out.bits.x, UInt<2>("h03")) @[WatermanSystolic.scala 82:79]
          node _T_9 = and(PEs[3].out.valid, _T_8) @[WatermanSystolic.scala 82:44]
          when _T_9 : @[WatermanSystolic.scala 82:104]
            resetReg <= UInt<1>("h01") @[WatermanSystolic.scala 83:18]
            stateReg <= UInt<2>("h00") @[WatermanSystolic.scala 84:18]
            skip @[WatermanSystolic.scala 82:104]
          skip @[Conditional.scala 39:67]
    
